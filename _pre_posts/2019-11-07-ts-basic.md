---
layout: post
title: "typescript 学习记录基础篇"
date: "2019-11-07"
author: "XuBaoshi"
header-img: "img/post-bg-02.jpg"
---

# typescript 学习记录基础篇

## 原始数据类型

### boolean

```javascript
let isDone: boolean = false;
```

在 ts 中使用 `new Boolean()` 创建的是 Boolean 类型的对象，不是 boolean

```javascript
// error
let createdByNewBoolean: boolean = new Boolean(1);

// right
let createdByNewBoolean: Boolean = new Boolean(1); // 非 boolean 类型
// right
let createdByBoolean: boolean = Boolean(1);
```

### number

es6 中二进制及八进制表示法， ts 会将其编译至十进制

```typescript
let decLiteral: number = 6;
// es6 二进制
let binaryLiteral: number = 0b1010;
// es6 八进制
let octalLiteral: number = 0o744;
```

// 编译后

```javascript
var decLiteral = 6;
// ES6 中的二进制表示法
var binaryLiteral = 10;
// ES6 中的八进制表示法
var octalLiteral = 484;
```

### string

```typescript
let myName: string = "Tom";
let myAge: number = 25;
let sentence: string = `Hello, my name is ${myName}.
I'll be ${myAge + 1} years old next month.`;
```

### void（空值）

在 ts 中可以使用 void 表示没有任何返回值得函数

```typescript
function alertName(): void {
  alert("name");
}
```

void 声明的变量不能赋值给其他对象

```typescript
let u1: void;
let num2: string = u1; // error 不能将类型“void”分配给类型“string”
// Type 'void' is not assignable to type 'number'.
```

### null & undefined

undefined 和 null 是所有类型的子类型，即 undefined 类型的变量，可以赋值给 number 类型的变量

```typescript
// right
let num: number = undefined;
// right
let u: undefined;
let num: number = u;
```

## 任意类型

通常一个普通类型在赋值过程中改变类型是不允许的 , any 是可以的

```typescript
// error
let myFavoriteNum: string = "seven";
myFavoriteNum = 7; // 不能将类型“7”分配给类型“string”

// right
let myFavoritNum1: any = "seven";
myFavoritNum1 = 7;
```

any 可以访问任何属性、使用任意方法

```typescript
let anyThing: any = "hello";
console.log(anyThing.name);
console.log(anyThing.name.name);
anyThing.setName();
```

未声明的变量均是 any 类型

```typescript
let any1;
console.log(any1.name);
console.log(any1.name.name);
any1.setName();
```

## 类型推论

变量声明时 如果初始赋值 ts 会根据初始值进行类型推断

```typescript
let myFavoriteNum = "seven"; // ts 推断变量  myFavoriteNum 为 string 类型
// error
myFavoriteNum = 7; // 不能将类型“7”分配给类型“string”
```

如果变量声明时没有初始赋值 类型则推断为 any

```typescript
let myFavoriteNum1;
myFavoriteNum1 = "seven";
myFavoritNum1 = 7;
```

## 联合类型

表示取值可以为多种类型的一种 类型之间使用 | 隔开

```typescript
let myFavoriteNumber: string | number;
myFavoriteNumber = "seven";
myFavoriteNumber = 7;
```

## 对象类型-接口

接口是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement），常用于对「对象的形状（Shape）」进行描述。

```typescript
interface Person {
  name: string;
  age: number;
}
let tom: Person = {
  name: "tom",
  age: 12
};

// 少一些 error
let jerry: Person = {
  name: "jerry"
};
// Property 'age' is missing in type '{ name: string; }' but required in type 'Person'

// 多一些属性 error
let marry: Person = {
  name: "marry",
  age: 16,
  sex: 0
};
// 不能将类型“{ name: string; age: number; sex: number; }”分配给类型“Person”。“sex”不在类型“Person”中
```

### 可选属性

可以同过在接口属性后添加 `?` 使其变成可选属性，可选的属性可以不存在，但依然不可以添加额外的属性

```typescript
interface Person1 {
  name: string;
  age?: number;
}
```

### 任意属性

一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集

```typescript
//right
interface Person2 {
  name: string;
  age?: string;
  [propName: string]: string;
}

let tom2: Person2 = {
  name: "tom2",
  age: "11",
  sex: "1"
};

// error
interface Person2 {
  name: string;
  age?: number;
  [propName: string]: string;
}

let tom2: Person2 = {
  name: "tom2",
  age: 11,
  sex: "1"
};
// 类型“number”的属性“age”不能赋给字符串索引类型“string”
```

### 只读类型

初始定义后不能在此地被赋值

```typescript
interface Person3 {
  readonly id: number;
  name: string;
  age?: number;
  [propName: string]: any;
}
let tom3: Person3 = {
  id: 1,
  name: "tom3",
  gender: 1
};

// error
tom3.id = 2;
// Cannot assign to 'id' because it is a read-only property
```

## 数组类型

### 定义 [类型+方括号]

```typescript
let fibobacci: number[] = [1, 2, 3, 4];

// 不允许其他类型出现
// error
let fiboacci1: number[] = [1, "2", 3];
// error
fibobacci.push("3");
// 不能将类型“string”分配给类型“number”
```

### 其他方式实现数组类型

```typescript
// 数组泛型
let fiboacci2: Array<number> = [1, 2, 3, 4];

// 用接口表示数组
interface NumberArray {
  [index: number]: number;
}
let fiboacci3: NumberArray = [1, 2, 3];
```

### 类数组

```typescript
// 类数组
function sum() {
  // 函数内部 arguments 不是数组类型 类数组
  // error
  let args: number[] = arguments;
  // Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join

  // 实现方式一
  let args1: {
    [index: number]: number;
    length: number;
    callee: Function;
  } = arguments;
  // 实现方式二 (IArguments 是 ts 内部定义好的（内置对象）， 实际上就是 type1 的声明方式)
  let args2: IArguments = arguments;
}
```

## 函数类型

## 类型断言

## 声明文件

## 内置对象
